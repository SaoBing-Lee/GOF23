工厂模式：
    -- 实现了创建者和调用者的分离；
    -- 详细分类：
        · 简单工厂模式  -- 用来生产同一等级结构中的任意产品（对于增加新的产品，需要修改已有的代码）
        · 工厂方法模式  -- 用来生产同一等级结构中的固定产品（支持任意增加产品）
        · 抽象工厂模式  -- 用来生产不同产品族的全部产品（对于增加新的产品，无能为力，支持增加产品族）


理论：工厂方法模式较好，实际，我们一般都是用简单工厂模式




    　1、简单工厂模式——代码无错就是优？

    　　　　　　简单工厂模式是由一个具体的类去创建其他类的实例，父类是相同的，父类是具体的。

    　　　　　　应该考虑用一个单独的类来做这个创造实例的过程，这就是工厂

    　　　　分析：

    　　　　　　1、简单运算工厂类：

    　　　　　　2、客户端代码：

    　　　　所有在用简单工厂的地方，都可以考虑用反射技术来去除switch或if，解除分支判断带来的耦合

    　　2、工厂方法模式——雷锋依然在人间

    　　　　　　工厂方法模式是有一个抽象的父类定义公共接口，子类负责生成具体的对象，这样做的目的是将类的实例化操作延迟到子类中完成。

    　　　　　　定义一个用于创建对象的接口，让子类决定实例化哪一个类； 使得一个类的实例化延迟到其子类。

    　　　　分析：

    　　　　　　1、简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。

    　　　　　　2、工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，

    　　　　　　　　也就是说工厂方法把简单工厂的内部逻辑判断移动到了客户端代码来进行。你想要加功能，本来是改工厂类，而现在是修改客户端。

    　　3、抽象工厂模式——就不能不换DB吗？

    　　　　　　抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定他们具体的类。

    　　　　　　它针对的是有多个产品的等级结构。而工厂方法模式针对的是一个产品的等级结构。

    　　　　分析：

    　　　　　　1、好处一是 易于交换产品系列，由于具体工厂类，例如：IFactory factory = new AccessFactory()，在一个应用中只需要在初始化的时候出现一次，

    　　　　　　　　这就使得改变一个应用的具体工厂变得非常容易，它只需要改变具体工厂即可使用不同的产品配置。

    　　　　　　2、好处二是 让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操作实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中。






设计模式之六大原则

    　　1、单一职责原则(SRP：Single responsibility principle)

    　　　　　就一个类而言，应该仅有一个引起它变化的原因； 通俗的说，即一个类只负责一项职责

    　　　　分析：

    　　　　　　1、如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力；

    　　　　　　      这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。

    　　　　　　2、软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。

    　　　　　　3、如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。

    　　2、开放-封闭原则（OCP：Open Closed Principle）

    　　　　  是说软件实体（类、模块、函数等等）应该可以扩展，但是不可以修改；

    　　　　　　特征1：对于扩展是开放的（Open for extension）；

    　　　　　　特征2：对于更改是封闭的（Closed for modification）。

    　　　　分析：

    　　　　　　1、在我们最初编写代码时，假设变化不会发生；当变化发生时，我们就创建抽象来隔离以后发生的同类变化。

    　　　　　　2、面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。

    　　　　　　3、我们希望的是在开发工作展开不久就知道可能发生的变化，查明可能发生的变化所等待的时间越长，要创建正确的抽象就越难。

    　　　　　　4、开发-封闭原则是面向对象设计的核心所在。 遵循此原则可以带来 可维护、可扩展、可复用、灵活性好的好处；

    　　　　　　　　开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用呈现中的每个部分都刻意地进行抽象同样不是一个好主意；

    　　　　　　　　　　拒绝不成熟的抽象和抽象本身一样重要。

    　　3、依赖倒转原则（）

    　　　　　A.高层模块不应该依赖低层模块。两个都应该依赖抽象

    　　　　　B.抽象不应该依赖细节，细节应该依赖抽象

    　　　　分析：

    　　　　　　1、就是要针对接口编程，不要对实现编程　　　　　　

    　　　　　　　    无论主板、CUP、内存都是在针对接口设计的，如果针对实现来设计，内存就要应对到具体的某个品牌的主板，那就会出现换内存需要把主板也换了的尴尬；

    　　　　　　2、高层模块不应该依赖低层模块，两者都应该依赖其抽象又如何理解呢？这个问题也可以这么问：为什么要叫倒置(倒转)呢？

    　　　　　　　　　　在面向过程的开发中，为了使用常用的代码可以复用，一般都会把这些常用的代码写成许许多多函数的程序库，这样我们做新项目的时候，

    　　　　　　　　就去调用这些函数就可以了。

    　　　　　　　　  例如：我们做的项目大多要访问数据库，所以我们就把数据库的代码写成了函数，每次做新项目时就去调用这些函数，这也就是高层依赖于低层模块了。

    　　　　　　　　　　如果我们的高层模块和低层模块都依赖于抽象，具体一点就是依赖于接口或抽象类，只要接口够稳定，那么任何一个的更改都不用担心其他受到影响了。



    　　4、里氏代换原则（）

    　　　　　子类型必须能够替换掉它们的父类型

    　　　　　 既：一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而其它察觉不出父类对象和子类对象的区别。

    　　　　　　　　也就是说，在软件里面，把父类都替换成它都替换成它的子类，程序的行为没有变化。

    　　　　分析：

    　　　　　　1、正因为有这个原则，使得继承复用成为了可能，

    　　　　　　　　只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。

    　　　　　　2、正是由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。

    　　　　　　3、依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，

    　　　　　　　　即使程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计了。

    　　5、迪米特法则（LKP：Least Knowledge Principle，又叫最少知识原则）

    　　　　  如果两个类不必彼此直接通信，那么这两个类就不应当直接的相互作用；如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。

    　　　　分析：

    　　　　　   1、在类的结构设计上，每一个类都应当尽量降低成员的访问权限；

    　　　　　　2、其根本思想是强调了类之间的松耦合；

    　　　　　　3、类之间的耦合越弱，越有利于复用，一个处于弱耦合的类被修改，不会对有关系的类造成波及。

    　　6、合成/聚合复用原则

    　　　　　尽量使用合成/聚合,尽量不要使用类继承

    　　　　　优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上；

    　　　　　这样类和类继承层次会保持较小规模，并且不太可能增长为不可能控制的庞然大物。

    　　　　分析：

    　　　　　　1、合成（Composition）和聚合（Aggregation）都是关联的特殊种类；

    　　　　　　2、聚合表示一种弱的“拥有”关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；

    　　　　　　3、合成则是一种强的“拥有”关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样

